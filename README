This is a mirror of http://www.vim.org/scripts/script.php?script_id=4602

DESCRIPTION
This plugin provides a toolbox of commands to delete, substitute, or
de-duplicate text based on a passed regular expression (or the last used
search pattern), something which would otherwise require multiple steps, a
complex sub-replace-expression or a macro. One way or the other, all
commands here are extensions of the :substitute command. Use them whenever
the general built-in doesn't suffice.

SOURCE
:DeleteExcept
    http://stackoverflow.com/questions/6249172/vim-delete-anything-other-than-pattern
:SubstituteInSearch inspired by
    http://stackoverflow.com/questions/13763880/in-vim-how-can-i-search-and-replace-every-other-match
:DeleteDuplicateLinesOf inspired by
    http://stackoverflow.com/questions/14236226/hanging-only-to-the-first-instance-of-the-line-and-deleting-all-further-copies
:DeleteDuplicateLinesIgnoring inspired by
    http://stackoverflow.com/questions/1896793/remove-duplicate-line-in-vim
:DeleteAllDuplicateLinesIgnoring inspired by
    http://stackoverflow.com/questions/22193596/in-vim-how-to-remove-all-lines-that-are-duplicate-somewhere

SEE ALSO
- The ExtractMatches.vim plugin (vimscript #4795) provides commands to yank
  matches into a register, optionally only unique matches without duplicates.
- The EditSimilar.vim plugin (vimscript #2544) uses the same
  {wildcard}={string} replacement pairs of :SubstituteWildcard, but for
  editing a similar file, e.g. via :EditSubstitute.

USAGE
:[range]SubstituteExcept/{pattern}/{string}/[flags] [count]
                        Replace instances of text in the current line /
                        [range] that do not match {pattern} / the last used
                        search pattern with {string}; "g" is implicit. Empty
                        lines (without any whitespace) are kept empty.
                        In {string}, & refers to the text that does not match,
                        whereas \1 etc. refer to the previous match of a
                        sub-expression in {pattern}.
:[range]SubstituteExcept [flags] [count]
                        Repeat the last substitution with the last used search
                        pattern, last used replacement string, and last used
                        :s_flags; "g" is implicit.

:[range]DeleteExcept [{pattern}]
:[range]DeleteExcept /{pattern}/[flags]
                        Delete all text in the current line / [range] except
                        for the text matching {pattern} / the last used search
                        pattern. For [flags], see :s_flags; "g" is implicit.

:[range]SubstituteSelected/{pattern}/{string}/[flags] {answers}
                        Replace matches of {pattern} in the current line /
                        [range] with {string}, determining whether a
                        particular match should be replaced on the sequence of
                        "y" or "n" (a count can be prefixed, e.g. "3y4n2y") or
                        numeric positions "2,5", or ranges "3-5" in {answers}.
                        If no numeric positions follow, the last "y" / "n"
                        sequence repeats for further matches. For example with
                        "ynn", the first match is replaced, the second and
                        third are not, the fourth is again replaced, ...
                        Handles & and \0, \1 .. \9 in {string}, also \=
                        sub-replace-expression and \r, \n, \t, \b.
:[range]SubstituteSelected [flags] [answers]
                        Repeat the last substitution with the last used search
                        pattern, last used replacement string, last used
                        :s_flags, and last used answers.

:[range]SubstituteSubsequent/{pattern}/{string}/[flags]
                        Replace all matches of {pattern} on or after the current
                        cursor position (and in all entire following lines) in
                        [range] with {string}.
                        For a "blockwise to end" replacement that is
                        restricted to positions on and after the current
                        column in all lines, pass the special flag [b].
:[range]SubstituteSubsequent/{pattern}/{string}/[flags] {answers}
                        Replace all matches of {pattern} on or after the current
                        cursor position in [range] with {string}, determining
                        whether a particular match should be replaced on the
                        sequence of "y" or "n" (a count can be prefixed, e.g.
                        "3y4n2y") or numeric positions "2,5", or ranges "3-5" in
                        {answers}, as with :SubstituteSelected.
:[range]SubstituteSubsequent [flags] [answers]
                        Repeat the last substitution with the last used search
                        pattern, last used replacement string, last used
                        :s_flags, and last used answers.

:[range]SubstituteInSearch/{pattern}/{string}/[flags] [count]
                        Within the current search pattern matches, replace all
                        matches of {pattern} with {string}. Shortcut for
                        :%s//\=substitute(submatch(0), "foo", "bar", "g")/gc
                       ~ is replaced with the {string} of the previous
                        :SubstituteInSearch.
                        Handles \= sub-replace-expression in {string}, which
                        can't be used recursively in the above built-in
                        :%s//\=...
                       [flags] and [count] apply to the outer matching of the
                        last search pattern. The [e] from :s_flags also
                        suppresses the error message when {pattern} never
                        matches.
                        To replace only the first occurrence of {pattern},
                        pass the special flag [f].
                        For a case-insensitive substitution, prepend '\c' to
                        {pattern}.
                        Does not modify the last search pattern quote/.
:[range]SubstituteInSearch [flags] [count]
                        Repeat last :SubstituteInSearch with same search
                        pattern and substitute string, but without the same
                        flags.

:[range]SubstituteMultiple /{pattern}/{string}/ [...] [flags] [count]
                        Change any of the {pattern} given to the corresponding
                        {string}. As this is done in a single :substitute,
                        this can have different (better) semantics than
                        sequential :s/new/old/ | s/older/newer/ commands. For
                        example, you can swap texts with this.
                        Note: You cannot use capturing groups /\( here!
                        Handles & in {string}. Whitespace in the substitution
                        pairs must be escaped; for a literal backslash search
                        / replace, use \\\\:
                            /C:\\\\/my\ drive\\\\/

:[range]SubstituteWildcard {wildcard}={string} [...] [flags] [count]
                        Change (first in the line, with "g" flag all) matches
                        of wildcard to {string}. Modeled after the Korn
                        shell's "cd {old} {new}" command.
                        Handles & in {string}. Whitespace in the substitution
                        pairs must be escaped; for a literal backslash search
                        / replace, use \\:
                            C:\\=my\ drive

                        For all following commands, the [!] suppresses the
                        error when there are no duplicates.

:[range]PrintDuplicateLinesOf[!] [{pattern}]
:[range]PrintDuplicateLinesOf[!] /{pattern}/
                        Print all occurrences of lines matching {pattern} (or
                        the current line, if omitted).
                        All matching lines are added to the jumplist, so you
                        can use CTRL-O to revisit the locations.

:[range]DeleteDuplicateLinesOf[!] [{pattern}]
:[range]DeleteDuplicateLinesOf[!] /{pattern}/
                        Delete all subsequent occurrences of lines matching
                        {pattern} (with . the current line; if omitted: the
                        last search pattern).

:[range]PrintDuplicateLinesIgnoring[!] [{pattern}]
:[range]PrintDuplicateLinesIgnoring[!] /{pattern}/
                        Print all occurrences of a line whose text (ignoring
                        any text matched by {pattern}) appears multiple times.
                        To ignore empty lines, use a {pattern} of ^$ (strict)
                        or ^\s*$ (lenient).
                        All matching lines are added to the jumplist, so you
                        can use CTRL-O to revisit the locations.

:[range]DeleteDuplicateLinesIgnoring[!] [{pattern}]
:[range]DeleteDuplicateLinesIgnoring[!] /{pattern}/
                        Delete all subsequent occurrences of a line (ignoring
                        any text matched by {pattern}).

:[range]DeleteAllDuplicateLinesIgnoring[!] [{pattern}]
:[range]DeleteAllDuplicateLinesIgnoring[!] /{pattern}/
                        Delete all (including the very first) occurrences of a
                        duplicate line (ignoring any text matched by
                        {pattern}).

:[range]PrintDuplicates[!] [{pattern}]
:[range]PrintDuplicates[!] /{pattern}/
                        Print all matches of {pattern} (if omitted: the last
                        search pattern) that appear multiple times in the
                        current line / [range].
                        To print all duplicate matches of {pattern} within a
                        single line, processing a [range] or the entire
                        buffer, use:
                        :global/^/PrintDuplicates! [{pattern}]
                        :global/^/PrintDuplicates! /{pattern}/
                       The [!] suppresses the error when there are no
                        duplicates in a particular line.

:[range]DeleteDuplicates[!] [{pattern}]
:[range]DeleteDuplicates[!] /{pattern}/
                        Delete all subsequent matches of {pattern} (or the
                        last search pattern, if omitted) except the first.

:[range]DeleteRanges[!] {range} [x]
:[range]YankRanges[!] {range} [x]
                        Within the entire buffer / passed [range], delete /
                        yank all lines that fall within {range} (with [!]: do
                        not fall within) into register [x] (or the unnamed
                        register).
:[range]PrintRanges[!] {range}
                        Within the entire buffer / passed [range], print all
                        lines that fall within {range} (with [!]: do not fall
                        within).
                        Each start of a block is added to the jumplist, so
                        you can use CTRL-O to revisit the locations.
